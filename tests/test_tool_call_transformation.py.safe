import json
import re
import unittest
import uuid
import pytest
from unittest.mock import AsyncMock, MagicMock

# Mock tool class to simulate external tools
class MockTool:
    def __init__(self, name, description):
        self.name = name
        self.description = description

    async def execute(self, **kwargs):
        # Simulate tool execution
        if self.name == "companies_house_lookup":
            return {
                "company_name": kwargs.get("company_name"),
                "company_number": "12345678",
                "status": "active"
            }
        elif self.name == "mortgage_calculator":
            return {
                "monthly_payment": 1000.00,
                "total_payment": 300000.00,
                "total_interest": 100000.00
            }
        elif self.name == "web_site_search":
            return {
                "results": [
                    {"title": "Test Result", "url": "https://example.com"}
                ]
            }
        return {"error": "Unknown tool"}

def clean_response(response):
    """Clean the response by removing markers and extracting the JSON."""
    if isinstance(response, str):
        # Remove any markers - be more aggressive about this
        markers = [
            r'<\|python_start\|>', r'<\|python_end\|>',
            r'<\|header_start\|>', r'<\|header_end\|>',
            r'<\|im_start\|>', r'<\|im_end\|>',
            r'<\|assistant\|>', r'<\|user\|>',
            r'<\|.*?\|>'  # Catch any other markers
        ]
        for marker in markers:
            response = re.sub(marker, '', response, flags=re.IGNORECASE)
        
        # Remove any explanatory text before or after JSON
        json_match = re.search(r'\{[\s\S]*\}', response)
        if json_match:
            response = json_match.group()
            
        # Remove any remaining whitespace or newlines
        response = response.strip()
        
        print(f"Cleaned response: {response}")
        return response
    return response

def transform_to_correct_format(response, current_agent=None):
    """Transform the response into the correct format."""
    if isinstance(response, str):
        response = clean_response(response)
        try:
            # First try to parse as JSON
            try:
                data = json.loads(response)
            except json.JSONDecodeError:
                # If not valid JSON, check if it's a text response that should be a tool call
                if current_agent and hasattr(current_agent, 'tools'):
                    # Check each configured tool
                    for tool_name in current_agent.tools:
                        # Create tool-specific keywords for matching
                        tool_keywords = {
                            "companies_house_lookup": ["look up", "company information", "company details"],
                            "mortgage_calculator": ["calculate", "mortgage", "payment"],
                            "web_site_search": ["search", "web", "find"]
                        }
                        
                        # Check if any of the tool's keywords are in the response
                        keywords = tool_keywords.get(tool_name, [])
                        if any(keyword in response.lower() for keyword in keywords):
                            # Create a tool call for the detected tool
                            tool_call = {
                                "role": "assistant",
                                "content": "",  # Empty string instead of null
                                "tool_calls": [{
                                    "function": {
                                        "name": tool_name,
                                        "arguments": json.dumps({
                                            "action": "search" if tool_name == "companies_house_lookup" else None,
                                            "company_name": "Test Company" if tool_name == "companies_house_lookup" else None,
                                            "query": None if tool_name == "companies_house_lookup" else None,
                                            "principal": 200000 if tool_name == "mortgage_calculator" else None,
                                            "annual_rate": 0.05 if tool_name == "mortgage_calculator" else None,
                                            "term_years": 25 if tool_name == "mortgage_calculator" else None,
                                            "calculate": "monthly_payment" if tool_name == "mortgage_calculator" else None
                                        })
                                    },
                                    "id": f"call_{uuid.uuid4().hex[:8]}",
                                    "type": "function"
                                }],
                                "tool_call_id": None,
                                "tool_name": None,
                                "response_type": "internal"
                            }
                            print(f"Created tool call: {json.dumps(tool_call, indent=2)}")
                            return tool_call
                return None

            # Handle legacy format with name/parameters first
            if "tool_calls" in data and isinstance(data["tool_calls"], list):
                tool_calls = []
                for tool_call in data["tool_calls"]:
                    if "name" in tool_call and "parameters" in tool_call:
                        tool_calls.append({
                            "function": {
                                "name": tool_call["name"],
                                "arguments": json.dumps(tool_call["parameters"])
                            },
                            "id": f"call_{uuid.uuid4().hex[:8]}",
                            "type": "function"
                        })
                if tool_calls:  # Only return if we found legacy format tool calls
                    return {
                        "role": "assistant",
                        "content": "",  # Empty string instead of null
                        "tool_calls": tool_calls,
                        "tool_call_id": None,
                        "tool_name": None,
                        "response_type": "internal"
                    }

            # If the response is already in the correct format, just fix arguments
            if all(key in data for key in ["role", "content", "tool_calls", "tool_call_id", "tool_name", "response_type"]):
                # Convert null content to empty string
                if data["content"] is None:
                    data["content"] = ""
                for tool_call in data["tool_calls"]:
                    if isinstance(tool_call["function"]["arguments"], dict):
                        tool_call["function"]["arguments"] = json.dumps(tool_call["function"]["arguments"])
                return data

            # If tool_calls is present and is a list, fix arguments if needed
            if "tool_calls" in data and isinstance(data["tool_calls"], list):
                transformed_tool_calls = []
                for tool_call in data["tool_calls"]:
                    if "function" in tool_call and isinstance(tool_call["function"], dict):
                        # Already in function format, just ensure arguments is a string
                        if isinstance(tool_call["function"].get("arguments"), dict):
                            tool_call["function"]["arguments"] = json.dumps(tool_call["function"]["arguments"])
                        transformed_tool_calls.append(tool_call)
                if transformed_tool_calls:  # Only return if we found function format tool calls
                    return {
                        "role": "assistant",
                        "content": "",  # Empty string instead of null
                        "tool_calls": transformed_tool_calls,
                        "tool_call_id": None,
                        "tool_name": None,
                        "response_type": "internal"
                    }

        except Exception as e:
            print(f"Error transforming response: {str(e)}")
            print(f"Response data: {data if 'data' in locals() else 'No data'}")
            return None
    return None

class MockAgent:
    def __init__(self, name, tools=None):
        self.name = name
        self.tools = tools or []

class TestToolCallTransformation:
    @pytest.fixture(autouse=True)
    def setup(self):
        # Create mock tools
        self.companies_house_tool = MockTool("companies_house_lookup", "Look up company information")
        self.mortgage_tool = MockTool("mortgage_calculator", "Calculate mortgage payments")
        self.web_search_tool = MockTool("web_site_search", "Search the web")
        self.external_tools = [self.companies_house_tool, self.mortgage_tool, self.web_search_tool]

    def test_clean_response(self):
        """Test cleaning of response with markers."""
        response = '<|python_start|>{"role": "assistant", "content": "test"}</|python_end|>'
        cleaned = clean_response(response)
        assert cleaned == '{"role": "assistant", "content": "test"}'

    def test_transform_valid_json(self):
        """Test transformation of valid JSON response."""
        response = {
            "role": "assistant",
            "content": None,
            "tool_calls": [{
                "function": {
                    "name": "companies_house_lookup",
                    "arguments": {"company_name": "Test Company"}
                },
                "id": "call_123",
                "type": "function"
            }],
            "tool_call_id": None,
            "tool_name": None,
            "response_type": "internal"
        }
        transformed = transform_to_correct_format(json.dumps(response))
        assert transformed is not None
        assert transformed["content"] == ""
        assert transformed["tool_calls"][0]["function"]["name"] == "companies_house_lookup"
        assert json.loads(transformed["tool_calls"][0]["function"]["arguments"]) == {"company_name": "Test Company"}

    def test_transform_text_to_tool_call(self):
        """Test transformation of text response to tool call."""
        agent = MockAgent("test_agent", ["companies_house_lookup"])
        response = "I'll look up the company information for Test Company."
        transformed = transform_to_correct_format(response, agent)
        assert transformed is not None
        assert transformed["tool_calls"][0]["function"]["name"] == "companies_house_lookup"
        args = json.loads(transformed["tool_calls"][0]["function"]["arguments"])
        assert args["company_name"] == "Test Company"
        assert args["action"] == "search"

    def test_transform_legacy_format(self):
        """Test transformation of legacy format with name/parameters."""
        response = {
            "role": "assistant",
            "content": None,
            "tool_calls": [{
                "name": "companies_house_lookup",
                "parameters": {"company_name": "Test Company"}
            }],
            "tool_call_id": None,
            "tool_name": None,
            "response_type": "internal"
        }
        transformed = transform_to_correct_format(json.dumps(response))
        assert transformed is not None
        assert transformed["tool_calls"][0]["function"]["name"] == "companies_house_lookup"
        assert json.loads(transformed["tool_calls"][0]["function"]["arguments"]) == {"company_name": "Test Company"}

    def test_transform_invalid_json(self):
        """Test handling of invalid JSON."""
        response = "This is not valid JSON"
        transformed = transform_to_correct_format(response)
        assert transformed is None

    def test_transform_with_multiple_tools(self):
        """Test transformation with multiple tools configured."""
        agent = MockAgent("test_agent", ["companies_house_lookup", "mortgage_calculator"])
        response = "I'll calculate the mortgage payment."
        transformed = transform_to_correct_format(response, agent)
        assert transformed is not None
        assert transformed["tool_calls"][0]["function"]["name"] == "mortgage_calculator"
        args = json.loads(transformed["tool_calls"][0]["function"]["arguments"])
        assert args["principal"] == 200000
        assert args["annual_rate"] == 0.05
        assert args["term_years"] == 25
        assert args["calculate"] == "monthly_payment"

    @pytest.mark.asyncio
    async def test_tool_execution(self):
        """Test execution of a tool call."""
        # Create a tool call
        tool_call = {
            "role": "assistant",
            "content": "",
            "tool_calls": [{
                "function": {
                    "name": "companies_house_lookup",
                    "arguments": json.dumps({"company_name": "Test Company"})
                },
                "id": "call_123",
                "type": "function"
            }],
            "tool_call_id": None,
            "tool_name": None,
            "response_type": "internal"
        }

        # Find and execute the tool
        tool_name = tool_call["tool_calls"][0]["function"]["name"]
        tool_args = json.loads(tool_call["tool_calls"][0]["function"]["arguments"])
        tool_call_id = tool_call["tool_calls"][0]["id"]

        tool = next((t for t in self.external_tools if t.name == tool_name), None)
        assert tool is not None, "Tool should be found"

        # Execute the tool
        result = await tool.execute(**tool_args)
        assert result is not None
        assert result["company_name"] == "Test Company"
        assert result["company_number"] == "12345678"

    @pytest.mark.asyncio
    async def test_tool_response_format(self):
        """Test the format of tool response messages."""
        tool_call = {
            "role": "assistant",
            "content": "",
            "tool_calls": [{
                "function": {
                    "name": "companies_house_lookup",
                    "arguments": json.dumps({"company_name": "Test Company"})
                },
                "id": "call_123",
                "type": "function"
            }],
            "tool_call_id": None,
            "tool_name": None,
            "response_type": "internal"
        }

        # Execute tool and create response
        tool_name = tool_call["tool_calls"][0]["function"]["name"]
        tool_args = json.loads(tool_call["tool_calls"][0]["function"]["arguments"])
        tool_call_id = tool_call["tool_calls"][0]["id"]

        tool = next((t for t in self.external_tools if t.name == tool_name), None)
        result = await tool.execute(**tool_args)

        # Create tool response message
        tool_response = {
            'content': json.dumps(result),
            'role': 'tool',
            'sender': None,
            'tool_calls': None,
            'tool_call_id': tool_call_id,
            'tool_name': tool_name,
            'response_type': 'internal'
        }

        # Verify response format
        assert tool_response['role'] == 'tool'
        assert tool_response['tool_name'] == tool_name
        assert tool_response['tool_call_id'] == tool_call_id
        assert tool_response['content'] is not None
        assert json.loads(tool_response['content'])['company_name'] == "Test Company"

    @pytest.mark.asyncio
    async def test_multiple_tool_execution(self):
        """Test execution of multiple tools in sequence."""
        # First tool call
        tool_call1 = {
            "role": "assistant",
            "content": "",
            "tool_calls": [{
                "function": {
                    "name": "companies_house_lookup",
                    "arguments": json.dumps({"company_name": "Test Company"})
                },
                "id": "call_123",
                "type": "function"
            }],
            "tool_call_id": None,
            "tool_name": None,
            "response_type": "internal"
        }

        # Execute first tool
        tool1 = next((t for t in self.external_tools if t.name == "companies_house_lookup"), None)
        result1 = await tool1.execute(**json.loads(tool_call1["tool_calls"][0]["function"]["arguments"]))
        assert result1 is not None
        assert result1["company_name"] == "Test Company"

        # Second tool call
        tool_call2 = {
            "role": "assistant",
            "content": "",
            "tool_calls": [{
                "function": {
                    "name": "mortgage_calculator",
                    "arguments": json.dumps({
                        "principal": 200000,
                        "annual_rate": 0.05,
                        "term_years": 25,
                        "calculate": "monthly_payment"
                    })
                },
                "id": "call_456",
                "type": "function"
            }],
            "tool_call_id": None,
            "tool_name": None,
            "response_type": "internal"
        }

        # Execute second tool
        tool2 = next((t for t in self.external_tools if t.name == "mortgage_calculator"), None)
        result2 = await tool2.execute(**json.loads(tool_call2["tool_calls"][0]["function"]["arguments"]))
        assert result2 is not None
        assert result2["monthly_payment"] == 1000.00

if __name__ == '__main__':
    pytest.main([__file__, '-v']) 